<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>한 단어 시(詩) 생성기</title>
  <style>
    :root{
      --bg:#0b0c10; --card:#12131a; --muted:#a1a7b3; --text:#e7ebf3; --accent:#8fd3ff;
      --warm:#ffd6a5; --calm:#b9e1ff; --pray:#cdb4db;
    }
    *{box-sizing:border-box}
    html,body{height:100%;}
    body{
      margin:0; font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans KR", "Apple SD Gothic Neo", Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color:var(--text); background:
        radial-gradient(60vmax 60vmax at 10% 10%, #1a2a6c22, transparent),
        radial-gradient(50vmax 50vmax at 90% 30%, #b21f1f22, transparent),
        radial-gradient(50vmax 50vmax at 50% 90%, #fdbb2d22, transparent),
        var(--bg);
    }
    .wrap{max-width:980px; margin:0 auto; padding:32px 20px 64px;}
    header{display:flex; align-items:center; gap:12px; margin-bottom:24px}
    .logo{width:42px; height:42px; border-radius:12px; background:linear-gradient(135deg,#8fd3ff,#cdb4db,#ffd6a5); box-shadow:0 6px 30px #0008}
    h1{font-size:clamp(20px,3.5vw,28px); margin:0}
    .muted{color:var(--muted)}

    .card{background:linear-gradient(180deg,#161722,#0f1017); border:1px solid #ffffff14; box-shadow:0 10px 40px #0007; border-radius:20px; padding:18px}
    .grid{display:grid; grid-template-columns:1.1fr .9fr; gap:18px}
    @media (max-width:860px){ .grid{grid-template-columns:1fr;}}

    label{font-size:12px; color:var(--muted); display:block; margin:12px 0 6px}
    input[type="text"], select{width:100%; background:#0f1118; color:var(--text); border:1px solid #ffffff22; border-radius:12px; padding:14px 14px; outline:none}
    input[type="range"]{width:100%}

    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .btn{appearance:none; border:none; background:#1a1c27; color:var(--text); padding:12px 16px; border-radius:14px; cursor:pointer; border:1px solid #ffffff18; transition:transform .08s ease, background .2s}
    .btn:hover{transform:translateY(-1px);}
    .btn.primary{background:linear-gradient(135deg,#1f5cff,#20c6ff); color:white; border:none}
    .btn.ghost{background:#0f1118}

    .poems{display:grid; grid-template-columns:repeat(3,1fr); gap:14px; margin-top:12px}
    @media (max-width:960px){.poems{grid-template-columns:1fr}}

    .poem-card{position:relative; border:1px solid #ffffff12; background:#0f1118; border-radius:16px; padding:16px; min-height:180px}
    .poem-title{font-size:13px; letter-spacing:.02em; color:#c7ccda; margin:0 0 10px}
    .poem-text{white-space:pre-wrap; line-height:1.7}
    .tag{display:inline-block; font-size:11px; padding:4px 8px; border-radius:999px; background:#ffffff10; border:1px solid #ffffff18}

    .actions{display:flex; gap:8px; margin-top:12px; flex-wrap:wrap}
    .chip{font-size:11px; padding:6px 10px; border-radius:999px; border:1px dashed #ffffff25; color:#cbd2e3}

    footer{margin-top:22px; color:#99a2b3; font-size:12px}
    .hint{border-left:3px solid #ffffff24; padding-left:10px}

    .accent-calm{color:var(--calm)}
    .accent-warm{color:var(--warm)}
    .accent-pray{color:var(--pray)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>한 단어 시(詩) 생성기</h1>
        <div class="muted">단어 하나로, 10초 안에 감동 시 3버전 생성 — API 없이 100% 오프라인</div>
      </div>
    </header>

    <div class="card grid">
      <section>
        <label for="word">키워드 (예: 새벽, 손, 위로)</label>
        <input id="word" type="text" placeholder="그대" />

        <div class="row">
          <div style="flex:1">
            <label for="mood">무드</label>
            <select id="mood">
              <option value="calm">차분</option>
              <option value="warm">따뜻</option>
              <option value="pray">기도</option>
            </select>
          </div>
          <div style="width:180px">
            <label for="lines">줄 수</label>
            <select id="lines">
              <option value="3">3줄 (짧게)</option>
              <option value="4" selected>4줄 (기본)</option>
              <option value="5">5줄 (조금 길게)</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:12px">
          <button class="btn primary" id="gen">시 3개 생성</button>
          <button class="btn" id="regen">랜덤 다시 뽑기</button>
          <button class="btn ghost" id="clear">지우기</button>
        </div>

        <footer style="margin-top:14px">
          <div class="hint">엔터를 눌러도 생성됩니다. 각 카드에서 복사/PNG/텍스트 저장 가능.</div>
        </footer>
      </section>

      <section>
        <div>
          <div class="row" style="justify-content:space-between; align-items:center">
            <div class="chip" id="seedInfo">seed: -</div>
            <div class="row">
              <span class="tag">무드: <span id="moodTag" class="accent-calm">차분</span></span>
            </div>
          </div>
        </div>
        <div class="poems" id="poems" aria-live="polite"></div>
      </section>
    </div>

    <footer>
      <p>ⓘ 완전 오프라인: 외부 API/서버 요청 없이 브라우저에서 즉시 동작합니다.</p>
    </footer>
  </div>

<script>
// ---------- 한국어 조사 처리 ----------
function hasJong(word){
  if(!word) return false;
  const ch = word.charCodeAt(word.length-1);
  if(ch < 0xAC00 || ch > 0xD7A3) return false; // 한글 아니면 false
  const index = ch - 0xAC00;
  const jong = index % 28; // 0이면 받침 없음
  return jong !== 0;
}
const JOSA = {
  IG: (w)=> hasJong(w)? '이':'가',
  EN: (w)=> hasJong(w)? '은':'는',
  RL: (w)=> hasJong(w)? '을':'를',
  WA: (w)=> hasJong(w)? '과':'와'
};
function withJosa(w, pair){
  switch(pair){
    case '이/가': return JOSA.IG(w);
    case '은/는': return JOSA.EN(w);
    case '을/를': return JOSA.RL(w);
    case '과/와': return JOSA.WA(w);
    default: return '';
  }
}

// ---------- 데이터 사전 ----------
const LEX = {
  baseNouns: ['새벽','빛','숨','바람','손','길','편지','기도','창문','적막','여정','눈빛','고요','별','시간','발자국'],
  verbs1: ['머문다','스며든다','감싼다','건넨다','기다린다','닿는다','밝힌다','익는다','둥글어진다','흐른다'],
  verbs2: ['안아 준다','불러 본다','써 내려간다','건너간다','깨운다','붙잡아 본다','맞이한다'],
  adj1: {
    calm: ['고요한','잔잔한','맑은','은근한','차분한','정갈한','서늘한'],
    warm: ['포근한','따사로운','노을빛','은은한','다정한','온기 어린','부드러운'],
    pray: ['간절한','은총의','숨은','빛나는','자비의','작은','담담한']
  },
  closers: {
    calm: ['나는 조금 잔잔한 사람이 된다','오늘도 무너지지 않는다','당신의 이름을 낮게 부른다'],
    warm: ['나는 끝내 따뜻한 사람이 된다','당신에게 미소를 건넨다','오늘이라는 선물을 껴안는다'],
    pray: ['나는 조용히 아멘을 배운다','당신의 평안을 구한다','작은 등불 하나를 지핀다']
  }
};

// 템플릿: {W}=키워드, {I}=이/가, {E}=은/는, {R}=을/를
const TEMPLATES = {
  calm: [
    '{W}{I} 지나간 자리마다 {ADJ} 숨이 머문다',
    '오늘, {W}{E} {VERB1} 마음에 {N} 한 줌',
    '{N} 끝에서 {W}{R} 부르며 나는 조금 {ADJ2} 사람이 된다',
    '낮은 숨 사이로 {W}{I} 조용히 {VERB2}'
  ],
  warm: [
    '{W}{E} 건네던 말끝에 {ADJ} 온기가 남아',
    '기억의 {N} 위로 햇살이 {VERB1}',
    '나는 오늘도 {W}{R} 품에 안고 {VERB2}',
    '작은 손끝에서 {ADJ2} 하루가 피어난다'
  ],
  pray: [
    '{W}{I} 닿는 곳마다 {ADJ} 빛이 머문다',
    '무릎 곁 {N} 하나, 조용히 {VERB1}',
    '나는 {W}{R} 불러 보며 {ADJ2} 길을 걷는다',
    '끝내 남는 것은 작은 평안, 그리고 너'
  ]
};

// ---------- 유틸 ----------
function choice(arr){ return arr[Math.floor(Math.random()*arr.length)] }
function shuffle(arr){ return [...arr].sort(()=>Math.random()-0.5) }
function seededRand(seed){ // Mulberry32
  let t = seed + 0x6D2B79F5; return ()=>{ t|=0; t = Math.imul(t ^ t>>>15, 1 | t); t += Math.imul(t ^ t>>>7, 61 | t); return ((t ^ t>>>14)>>>0) / 4294967296 }
}

// ---------- 시 생성 ----------
function makePoem(keyword, mood, lines, rng){
  const W = keyword && keyword.trim()? keyword.trim(): '그대';
  const N = choice(LEX.baseNouns);
  const ADJ = choice(LEX.adj1[mood]);
  const ADJ2 = choice(LEX.adj1[mood].filter(x=>x!==ADJ)) || ADJ;
  const VERB1 = choice(LEX.verbs1);
  const VERB2 = choice(LEX.verbs2);
  const pool = TEMPLATES[mood];
  const templates = shuffle(pool).slice(0, Math.max(3, Math.min(5, lines)));
  const out = templates.slice(0, lines).map(t=>
    t.replaceAll('{W}', W)
     .replaceAll('{I}', withJosa(W,'이/가'))
     .replaceAll('{E}', withJosa(W,'은/는'))
     .replaceAll('{R}', withJosa(W,'을/를'))
     .replaceAll('{N}', N)
     .replaceAll('{ADJ}', ADJ)
     .replaceAll('{ADJ2}', ADJ2)
     .replaceAll('{VERB1}', VERB1)
     .replaceAll('{VERB2}', VERB2)
  );
  // 마지막 줄이 애매하면 클로저로 치환
  if(out.length){ out[out.length-1] = choice([out[out.length-1], LEX.closers[mood][Math.floor(Math.random()*LEX.closers[mood].length)]]); }
  return out;
}

// ---------- 렌더링 ----------
const poemsEl = document.getElementById('poems');
const moodSel = document.getElementById('mood');
const wordInput = document.getElementById('word');
const lineSel = document.getElementById('lines');
const seedInfo = document.getElementById('seedInfo');
const moodTag = document.getElementById('moodTag');

function currentMoodLabel(){
  return {calm:'차분', warm:'따뜻', pray:'기도'}[moodSel.value];
}
function updateMoodTag(){
  moodTag.textContent = currentMoodLabel();
  moodTag.className = 'accent-' + moodSel.value;
}
updateMoodTag();

function generateAll(seed){
  const lines = parseInt(lineSel.value,10);
  const mood = moodSel.value;
  const W = wordInput.value.trim()||'그대';
  const rand = seed ?? Math.floor(Date.now() % 1e9);
  const rng = seededRand(rand);
  seedInfo.textContent = 'seed: ' + rand;
  poemsEl.innerHTML = '';
  const variants = ['A','B','C'];
  for(const tag of variants){
    const poem = makePoem(W, mood, lines, rng);
    poemsEl.appendChild(renderPoemCard(tag, W, mood, poem));
  }
}

function renderPoemCard(tag, W, mood, lines){
  const card = document.createElement('div');
  card.className = 'poem-card';
  const title = document.createElement('div');
  title.className = 'poem-title';
  title.innerHTML = `<strong>버전 ${tag}</strong> · <span class="accent-${mood}">${currentMoodLabel()}</span> · 키워드: <em>${escapeHtml(W)}</em>`;
  const text = document.createElement('div');
  text.className = 'poem-text';
  text.textContent = lines.join('\n');
  const actions = document.createElement('div');
  actions.className = 'actions';

  const btnCopy = button('복사', ()=>{ copyText(lines.join('\n')); toast('복사했어요'); });
  const btnTxt = button('.txt 저장', ()=>{ saveTxt(lines, `poem_${Date.now()}.txt`); });
  const btnPng = button('PNG 이미지', ()=>{ savePng(W, mood, lines); });

  actions.append(btnCopy, btnTxt, btnPng);
  card.append(title, text, actions);
  return card;
}

function button(label, onClick){
  const b = document.createElement('button');
  b.className = 'btn ghost';
  b.textContent = label; b.onclick = onClick; return b;
}

function copyText(s){ navigator.clipboard?.writeText(s).catch(()=>{}); }
function saveTxt(lines, filename){
  const blob = new Blob([lines.join('\n')], {type:'text/plain;charset=utf-8'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click(); URL.revokeObjectURL(a.href);
}

// ---------- PNG 렌더 ----------
function savePng(keyword, mood, lines){
  const W = 1080, H = 1350; // 인스타 게시용 비율(4:5)
  const canvas = document.createElement('canvas'); canvas.width=W; canvas.height=H;
  const ctx = canvas.getContext('2d');

  // 배경 그라디언트
  const grads = {
    calm: ['#0b1022','#113457','#0b2238'],
    warm: ['#1f1020','#442012','#3a1208'],
    pray: ['#0f0e1a','#2a1c46','#1a1431']
  }[mood];
  const g = ctx.createLinearGradient(0,0,W,H);
  g.addColorStop(0, grads[0]); g.addColorStop(.6, grads[1]); g.addColorStop(1, grads[2]);
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

  // 장식 원
  for(let i=0;i<5;i++){
    const rg = ctx.createRadialGradient(W*Math.random(), H*Math.random(), 10, W*Math.random(), H*Math.random(), 400);
    rg.addColorStop(0, 'rgba(255,255,255,0.06)'); rg.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = rg; ctx.beginPath(); ctx.arc(W*Math.random(), H*Math.random(), 400*(.4+Math.random()), 0, Math.PI*2); ctx.fill();
  }

  // 타이틀
  ctx.fillStyle = 'rgba(255,255,255,.9)';
  ctx.font = '28px \"Noto Sans KR\", system-ui';
  ctx.fillText('한 단어 시 · ' + ({calm:'차분', warm:'따뜻', pray:'기도'}[mood]), 60, 90);
  ctx.fillStyle = 'rgba(255,255,255,.7)';
  ctx.font = '24px \"Noto Sans KR\", system-ui';
  ctx.fillText('키워드: ' + keyword, 60, 130);

  // 본문
  const margin = 100, maxWidth = W - margin*2; let y = 260;
  ctx.fillStyle = '#f6f7fb';
  ctx.font = '48px \"Noto Sans KR\", system-ui';
  const wrapped = lines.map(line=>wrapText(ctx, line, maxWidth));
  for(const seg of wrapped){
    for(const s of seg){ ctx.fillText(s, margin, y); y += 66; }
    y += 16; // 줄 간 간격
  }

  // 서명
  ctx.fillStyle = 'rgba(255,255,255,.5)';
  ctx.font = '20px system-ui';
  const stamp = new Date().toLocaleDateString('ko-KR');
  ctx.fillText(stamp + ' · generated offline', 60, H-60);

  const link = document.createElement('a'); link.href = canvas.toDataURL('image/png'); link.download = `poem_${Date.now()}.png`; link.click();
}

function wrapText(ctx, text, maxWidth){
  const words = text.split(' ');
  const lines = []; let cur = '';
  for(const w of words){
    const test = cur? cur + ' ' + w : w;
    if(ctx.measureText(test).width <= maxWidth){ cur = test; }
    else{ lines.push(cur); cur = w; }
  }
  if(cur) lines.push(cur);
  // 한글은 공백이 적으므로, 아주 긴 연속 텍스트를 대략 반으로 자르기
  for(let i=0;i<lines.length;i++){
    if(ctx.measureText(lines[i]).width > maxWidth){
      const mid = Math.floor(lines[i].length/2);
      lines.splice(i,1, lines[i].slice(0,mid), lines[i].slice(mid));
    }
  }
  return lines;
}

// ---------- 이벤트 ----------
function escapeHtml(s){ return s?.replace(/[&<>"]+/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[m])) || '' }

document.getElementById('gen').addEventListener('click', ()=> generateAll());

document.getElementById('regen').addEventListener('click', ()=> generateAll(Math.floor(Math.random()*1e9)));

document.getElementById('clear').addEventListener('click', ()=>{ poemsEl.innerHTML=''; seedInfo.textContent='seed: -'; wordInput.value=''; });

wordInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ generateAll(); }});

moodSel.addEventListener('change', updateMoodTag);

// 첫 화면 예시 생성
setTimeout(()=>generateAll(), 60);
</script>
</body>
</html>
